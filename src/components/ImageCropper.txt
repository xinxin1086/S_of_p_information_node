<template>
  <!-- 头像上传触发按钮 -->
  <div class="avatar-upload-trigger" @click="openCropModal">
    <slot name="trigger">
      <div class="info-avatar-uploader">
        <img
            v-if="previewUrl"
            :src="previewUrl"
            class="info-avatar"
            alt="预览"
        />
        <i v-else class="el-icon-plus info-avatar-uploader-icon"></i>
      </div>
    </slot>
  </div>

  <!-- 裁剪弹窗 -->
  <el-dialog
      title="调整头像尺寸"
      v-model="isCropModalOpen"
      width="500px"
      :close-on-click-modal="false"
      :destroy-on-close="true"
  >
    <div class="crop-container">
      <div class="crop-wrapper" ref="cropWrapperRef">
        <!-- 图片容器 -->
        <div class="crop-image-container" ref="imageContainerRef">
          <img ref="cropImageRef" :src="cropImageUrl" class="crop-image" alt="待裁剪" @load="initCrop" />
        </div>
        <!-- 裁剪框 -->
        <div class="crop-box" ref="cropBoxRef" @mousedown="startDrag"></div>
        <!-- 裁剪框控制点 -->
        <div class="crop-resize-handle" ref="resizeHandleRef" @mousedown="startResize"></div>
        <!-- 遮罩层（动态跟随裁剪框） -->
        <div class="crop-mask" ref="cropMaskRef"></div>
      </div>
    </div>

    <template #footer>
      <button type="button" class="info-btn info-cancel-btn" @click="closeCropModal">取消</button>
      <button type="button" class="info-btn info-submit-btn" @click="confirmCrop">确认裁剪</button>
    </template>
  </el-dialog>
</template>

<script setup>
import { ref, nextTick, onUnmounted, watch } from 'vue';
import { formatAvatarUrl } from '@/utils/format.js';

// Props
const props = defineProps({
  modelValue: String,
  size: { type: Number, default: 200 },
});

// Emits
const emit = defineEmits(['update:modelValue', 'cropped-file-ready', 'upload-fail']);

// 状态
const isCropModalOpen = ref(false);
const cropImageUrl = ref('');
const previewUrl = ref(formatAvatarUrl(props.modelValue) || '');
const tempBlobUrls = ref([]);

// DOM引用
const cropWrapperRef = ref(null);
const imageContainerRef = ref(null);
const cropImageRef = ref(null);
const cropBoxRef = ref(null);
const resizeHandleRef = ref(null);
const cropMaskRef = ref(null); // 遮罩层引用

// 裁剪状态
const cropBox = ref({ x: 0, y: 0, width: 0, height: 0 });
const isDragging = ref(false);
const isResizing = ref(false);
const startPos = ref({ x: 0, y: 0 });
const startBox = ref({ x: 0, y: 0, width: 0, height: 0 });

// 打开弹窗选择图片
const openCropModal = () => {
  isCropModalOpen.value = true;
  nextTick(() => {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/jpeg,image/png';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);

    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) {
        closeCropModal();
        return;
      }

      // 校验文件
      if (file.size > 2 * 1024 * 1024) {
        emit('upload-fail', '文件大小不能超过2MB');
        closeCropModal();
        document.body.removeChild(fileInput);
        return;
      }
      if (!['image/jpeg', 'image/png'].includes(file.type)) {
        emit('upload-fail', '仅支持JPG、PNG格式图片');
        closeCropModal();
        document.body.removeChild(fileInput);
        return;
      }

      // 加载图片
      const blobUrl = URL.createObjectURL(file);
      cropImageUrl.value = blobUrl;
      tempBlobUrls.value.push(blobUrl);
      document.body.removeChild(fileInput);
    };

    fileInput.click();
  });
};

// 初始化裁剪框（图片加载完成后）
const initCrop = () => {
  const container = imageContainerRef.value;
  const image = cropImageRef.value;
  const box = cropBoxRef.value;
  const mask = cropMaskRef.value;

  if (!container || !image || !box || !mask) return;

  // 容器和图片尺寸
  const containerWidth = container.offsetWidth;
  const containerHeight = container.offsetHeight;
  const imageWidth = image.offsetWidth;
  const imageHeight = image.offsetHeight;

  // 裁剪框大小（正方形，80%容器宽度）
  const boxSize = Math.min(containerWidth, containerHeight) * 0.8;
  cropBox.value = {
    width: boxSize,
    height: boxSize,
    x: (containerWidth - boxSize) / 2,
    y: (containerHeight - boxSize) / 2,
  };

  // 设置裁剪框样式 + 遮罩层同步
  updateCropBoxAndMask();
};

// 关键修复：同步更新裁剪框和遮罩层（视觉与实际裁剪区域一致）
const updateCropBoxAndMask = () => {
  const box = cropBoxRef.value;
  const mask = cropMaskRef.value;
  if (!box || !mask) return;

  // 1. 更新裁剪框样式
  box.style.width = `${cropBox.value.width}px`;
  box.style.height = `${cropBox.value.height}px`;
  box.style.left = `${cropBox.value.x}px`;
  box.style.top = `${cropBox.value.y}px`;

  // 2. 动态设置遮罩层CSS变量，让透明区域跟随裁剪框
  mask.style.setProperty('--crop-x', `${cropBox.value.x}px`);
  mask.style.setProperty('--crop-y', `${cropBox.value.y}px`);
  mask.style.setProperty('--crop-width', `${cropBox.value.width}px`);
  mask.style.setProperty('--crop-height', `${cropBox.value.height}px`);
};

// 开始拖拽裁剪框
const startDrag = (e) => {
  e.preventDefault();
  isDragging.value = true;
  startPos.value = { x: e.clientX, y: e.clientY };
  startBox.value = { ...cropBox.value };

  // 绑定鼠标事件
  document.addEventListener('mousemove', handleDrag);
  document.addEventListener('mouseup', stopDrag);
};

// 处理拖拽
const handleDrag = (e) => {
  if (!isDragging.value) return;

  const container = imageContainerRef.value;
  if (!container) return;

  // 计算偏移
  const dx = e.clientX - startPos.value.x;
  const dy = e.clientY - startPos.value.y;

  // 新位置
  let newX = startBox.value.x + dx;
  let newY = startBox.value.y + dy;

  // 边界限制
  const containerWidth = container.offsetWidth;
  const containerHeight = container.offsetHeight;
  newX = Math.max(0, Math.min(newX, containerWidth - cropBox.value.width));
  newY = Math.max(0, Math.min(newY, containerHeight - cropBox.value.height));

  // 更新裁剪框位置 + 遮罩层同步
  cropBox.value.x = newX;
  cropBox.value.y = newY;
  updateCropBoxAndMask();
};

// 停止拖拽
const stopDrag = () => {
  isDragging.value = false;
  document.removeEventListener('mousemove', handleDrag);
  document.removeEventListener('mouseup', stopDrag);
};

// 开始调整裁剪框大小
const startResize = (e) => {
  e.preventDefault();
  isResizing.value = true;
  startPos.value = { x: e.clientX, y: e.clientY };
  startBox.value = { ...cropBox.value };

  // 绑定鼠标事件
  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
};

// 处理调整大小
const handleResize = (e) => {
  if (!isResizing.value) return;

  const container = imageContainerRef.value;
  if (!container) return;

  // 计算新尺寸（正方形）
  const dx = e.clientX - startPos.value.x;
  const dy = e.clientY - startPos.value.y;
  const newSize = Math.max(50, Math.min(
      startBox.value.width + dx,
      startBox.value.height + dy,
      container.offsetWidth - startBox.value.x,
      container.offsetHeight - startBox.value.y
  ));

  // 更新裁剪框尺寸 + 遮罩层同步
  cropBox.value.width = newSize;
  cropBox.value.height = newSize;
  updateCropBoxAndMask();
};

// 停止调整大小
const stopResize = () => {
  isResizing.value = false;
  document.removeEventListener('mousemove', handleResize);
  document.removeEventListener('mouseup', stopResize);
};

// 确认裁剪（核心逻辑：精准匹配视觉区域）
const confirmCrop = () => {
  const image = cropImageRef.value;
  const container = imageContainerRef.value;
  if (!image || !container) {
    emit('upload-fail', '请先选择图片');
    return;
  }

  try {
    // 创建Canvas
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = props.size;
    canvas.height = props.size;

    // 计算裁剪比例（原始图片 vs 显示容器，确保精准裁剪）
    const imageWidth = image.naturalWidth;
    const imageHeight = image.naturalHeight;
    const displayWidth = image.offsetWidth;
    const displayHeight = image.offsetHeight;
    const scaleX = imageWidth / displayWidth;
    const scaleY = imageHeight / displayHeight;

    // 原始图片上的裁剪区域（与视觉裁剪框完全对应）
    const cropX = cropBox.value.x * scaleX;
    const cropY = cropBox.value.y * scaleY;
    const cropWidth = cropBox.value.width * scaleX;
    const cropHeight = cropBox.value.height * scaleY;

    // 绘制裁剪区域（无变形，精准匹配）
    ctx.drawImage(
        image,
        cropX, cropY, cropWidth, cropHeight, // 原始图片裁剪区域
        0, 0, props.size, props.size         // 目标尺寸（正方形）
    );

    // 转换为Blob
    canvas.toBlob((blob) => {
      const croppedFile = new File([blob], `avatar_${Date.now()}.jpg`, {
        type: 'image/jpeg',
        lastModified: Date.now()
      });

      // 生成预览URL
      const previewBlobUrl = URL.createObjectURL(blob);
      previewUrl.value = previewBlobUrl;
      tempBlobUrls.value.push(previewBlobUrl);

      // 通知父组件 + 同步v-model
      emit('update:modelValue', previewBlobUrl);
      emit('cropped-file-ready', croppedFile);
      closeCropModal();
    }, 'image/jpeg', 0.9);
  } catch (error) {
    emit('upload-fail', error.message || '裁剪失败，请重试');
  }
};

// 关闭弹窗
const closeCropModal = () => {
  isCropModalOpen.value = false;
  // 释放Blob URL
  tempBlobUrls.value.forEach(url => URL.revokeObjectURL(url));
  tempBlobUrls.value = [];
  cropImageUrl.value = '';
};

// 组件卸载
onUnmounted(() => {
  // 移除事件监听
  document.removeEventListener('mousemove', handleDrag);
  document.removeEventListener('mouseup', stopDrag);
  document.removeEventListener('mousemove', handleResize);
  document.removeEventListener('mouseup', stopResize);
  // 释放Blob URL
  tempBlobUrls.value.forEach(url => URL.revokeObjectURL(url));
});

// 监听父组件传入的URL（编辑页回显）
watch(
    () => props.modelValue,
    (newVal) => {
      previewUrl.value = formatAvatarUrl(newVal) || '';
    },
    { immediate: true }
);
</script>

<style scoped>
/* 触发按钮 */
.avatar-upload-trigger {
  cursor: pointer;
  display: inline-block;
}

/* 头像预览 */
.info-avatar-uploader {
  width: 100px;
  height: 100px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px dashed #dcdfe6;
  position: relative;
}

.info-avatar-uploader-icon {
  font-size: 28px;
  color: #8c939d;
  width: 100%;
  height: 100%;
  line-height: 100px;
  text-align: center;
}

.info-avatar {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* 裁剪容器 */
.crop-container {
  width: 100%;
  height: 350px;
  position: relative;
}

.crop-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
  background-color: #f8f9fa;
}

/* 图片容器 */
.crop-image-container {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.crop-image {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

/* 裁剪框 */
.crop-box {
  position: absolute;
  border: 2px solid #409EFF;
  background-color: rgba(64, 158, 255, 0.1);
  cursor: move;
  z-index: 2;
}

/* 调整控制点 */
.crop-resize-handle {
  position: absolute;
  width: 10px;
  height: 10px;
  background-color: #409EFF;
  border-radius: 50%;
  bottom: -5px;
  right: -5px;
  cursor: nwse-resize;
  z-index: 3;
}

/* 遮罩层（核心修复：使用CSS变量动态更新透明区域） */
.crop-mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 1;
  transition: clip-path 0.1s ease; /* 平滑过渡 */
  /* 通过CSS变量绑定裁剪框位置和尺寸 */
  clip-path: polygon(
      0 0,
      0 100%,
      var(--crop-x) 100%,
      var(--crop-x) var(--crop-y),
      calc(var(--crop-x) + var(--crop-width)) var(--crop-y),
      calc(var(--crop-x) + var(--crop-width)) calc(var(--crop-y) + var(--crop-height)),
      var(--crop-x) calc(var(--crop-y) + var(--crop-height)),
      var(--crop-x) 100%,
      100% 100%,
      100% 0
  );
}

/* 按钮样式 */
.info-btn {
  border: none;
  border-radius: 8px;
  padding: 10px 16px;
  cursor: pointer;
  color: #fff;
  font-size: 14px;
}

.info-submit-btn {
  background-color: #67C23A;
  margin-right: 12px;
}

.info-cancel-btn {
  background-color: #909399;
}
</style>